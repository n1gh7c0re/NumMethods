n = 10;
format longEng %изменяет формат выходного отображения на longEng (15 цифр после запятой)

%создание симметричных матриц
% [Q, r]=qr(rand(n)); %генерирует случайную матрицу 10 на 10, разложенную на Q*R
% QT = transpose(Q); %транспонирует матрицу Q
% FileName51=fopen('file1.txt','w'); %открывает файл для записи данных
File1 = fopen('polynomial1.txt', 'r');
% %1)
vec = ones([n, 1]);
for i = 1:n
    vec(i) = i;
end
% D = diag(vec); %диагональная матрица с нормальными сч на диагонали
% A = QT * D * Q; %получает симметричную матрицу
% for j = 1:n
%     for m = 1:n %записывает в файл элементы матрицы
%         fprintf(FileName51,'%.15f ', A(j,m));
%     end
% end
p = fscanf(File1, '%f ', 11);
root1 = sort(roots(p)); %корни для хороших сч
norm1 = norm(root1 - vec); %норма для хороших сч симметричной матрицы
%2)
vec(9) = -vec(10);
% D = diag(vec); %диагональная матрица с плохими сч на диагонали (2 сч отличаются знаком)
% A = QT * D * Q; %получает симметричную матрицу
% for j = 1:n
%     for m = 1:n %записывает в файл элементы матрицы
%         fprintf(FileName51,'%.15f ', A(j,m));
%     end
% end

vec1 = vec;
vec1(1) = vec(9);
for i = 2:9
    vec1(i) = vec(i-1);
end
p = fscanf(File1, '%f ', 11);
root2 = sort(roots(p)); %корни для плохих сч (2 сч отличаются знаком)
norm2 = norm(vec1 - root2); %норма для плохих сч (2 сч отличаются знаком)
%3)
vec(9) = vec(10) + 0.1*rand;
% D = diag(vec); %диагональная матрица с плохими сч на диагонали (2 сч близки друг к другу)
% A = QT * D * Q; %получает симметричную матрицу
% for j = 1:n
%     for m = 1:n %записывает в файл элементы матрицы
%         fprintf(FileName51,'%.15f ', A(j,m));
%     end
% end
p = fscanf(File1, '%f ', 11);
root3 = sort(roots(p)); %корни для плохих сч (2 сч близки друг к другу)
vec2 = vec;
vec2(10) = vec(9);
vec2(9) = vec(10);
norm3 = norm(vec2 - root3); %норма для плохих сч (2 сч близки друг к другу)

%создание НЕ симметричных матриц
% B = rand(n, n);
% B1 = inv(B); %получает обратную матрицу
% FileName52=fopen('file2.txt','w'); %открывает файл для записи данных
File2 = fopen('polynomial2.txt', 'r');
% %4)
vec = ones([n, 1]);
for i = 1:n
    vec(i) = i;
end
% D = diag(vec); %диагональная матрица с нормальными сч на диагонали
% A = B1 * D * B; %получает не симметричную матрицу
% for j = 1:n
%     for m = 1:n %записывает в файл элементы матрицы
%         fprintf(FileName52,'%.15f ', A(j,m));
%     end
% end
p = fscanf(File2, '%f ', 11);
root4 = sort(roots(p)); %корни для хороших сч
norm4 = norm(root4 - vec); %норма для хороших сч симметричной матрицы

%5)
vec(9) = -vec(10);
% D = diag(vec); %диагональная матрица с плохими сч на диагонали (2 сч отличаются знаком)
% A = B1 * D * B; %получает не симметричную матрицу
% for j = 1:n
%     for m = 1:n %записывает в файл элементы матрицы
%         fprintf(FileName52,'%.15f ', A(j,m));
%     end
% end
p = fscanf(File2, '%f ', 11);
root5 = sort(roots(p)); %корни для плохих сч (2 сч отличаются знаком)
vec1 = vec;
vec1(1) = vec(9);
for i = 2:9
    vec1(i) = vec(i-1);
end
norm5 = norm(vec1 - root5); %норма для плохих сч (2 сч отличаются знаком)

%6)
vec(9) = vec(10) + 0.1*rand;
% D = diag(vec); %диагональная матрица с плохими сч на диагонали (2 сч близки друг к другу)
% A = B1 * D * B; %получает не симметричную матрицу
% for j = 1:n
%     for m = 1:n %записывает в файл элементы матрицы
%         fprintf(FileName52,'%.15f ', A(j,m));
%     end
% end
p = fscanf(File2, '%f ', 11);
root6 = sort(roots(p)); %корни для плохих сч (2 сч близки друг к другу)
vec2 = vec;
vec2(10) = vec(9);
vec2(9) = vec(10);
norm6 = norm(vec2 - root6); %норма для плохих сч (2 сч близки друг к другу)

%график зависимости времени выполнения метода t от размерности матрицы N
x1 = xlsread('time5.csv', 'B1:B6'); %считывает из таблицы значения для оси Х
y1 = xlsread('time5.csv', 'A1:A6'); %считывает из таблицы значения для оси Y

%крайние точки аппроксимирующей прямой для графика времени
x12 = x1(1);
x13 = x1(6);
y12 = y1(1)/1.1;
y13 = y1(6)/1.2;

figure
loglog(x1, y1, '-b','LineWidth', 2); %строит график
grid on; %строит сетку
hold on; %сохраняет график
loglog([x12 x13], [y12 y13], '--r','LineWidth', 2); %строит аппроксимирующую прямую
hold on; %сохраняет график
title('График зависимости времени выполнения метода t от размерности матрицы N') %заголовок
xlabel('Размерность матрицы N') %подпись оси х
ylabel('Время выполнения метода t, сек') %подпись оси у
%легенда
legend('Зависимость времени выполнения метода от размерности матрицы', ...
    'Аппроксимирующая прямая');